# 삼색볼펜법을 통한 스터디 내용 정리

### 🔴 빨간색 부분

- 435p. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화(generalization)이고 자식 클래스는 부모 클래스의 특수화(specialization)이다.
- 435p. 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다.
- 436p. 객체기반 프로그래밍(Object-Based Programming)이란 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다.
- 437p. 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.
- 438p. 정리하면 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.
- 438p. 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
- 439p. 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하라.
- 441p. 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입(supertype)이라고 부르고 더 특수한 타입을 서브타입(subtype)이라고 부른다.
- 443p. 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.
- 443p. 객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.
- 443p. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
- 447p. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
- 448p. 일반적으로 instanceof처럼 객체의 타입을 확인하는 코드는 새로운 타입을 추가할 때마다 코드 수정을 요구하기 때문에 개방-폐쇄 원칙을 위반한다.
- 450p. 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(Interface Segregation Priciple, ISP)이라고 부른다.
- 451p. 요점은 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중하는 것이다.
- 453p. 리스코프 치환 원칙을 한마디로 정의하면 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
- 457p. 중요한 것은 클라이언트 관점에서 행동이 호환되는지 여부다. 그리고 행동이 호환될 경우에만 자식 클래스가 부모 클래스 대신 사용될 수 있다.
- 457p. 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
- 458p. 리스코프 치환 원칙은 "클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다"는 아주 중요한 결론을 이끈다.
- 458p. 행동 호환성과 리스코프 치환 원칙에서 한 가지만 기억해야 한다면 이것을 기억하라. 대체 가능성을 결정하는 것은 클라이언트다.
- 463p. 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은 클라이언트가 슈퍼타입과 맺은 계약을 서브타입이 준수하는 것뿐이다.
- 469p. 서브타이핑을 위해 상속읋 사용하고 있다면 부모 클래스가 클라이언트와 맺고 있는 계약에 관해 깊이 있게 고민해보기 바란다.

### 🔵 파란색 부분

- 435p. 상속의 첫 번째 용도는 타입 계층을 구현하는 것이다.
- 435p. 상속의 두번째 용도는 코드 재사용이다.
- 435p. 동이란 메세지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.
- 435p. 타입 사이의 관계를 고려핮 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안 된다.
- 438p. 객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체들을 동일한 타입으로 분류할 수 있다.
- 440p. 다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있다. 반면 포홤되는 타입은 좀 더 특수하고 구체적이다.
- 440p. 타입 계층을 표현 할 때는 더 일반적인 타입을 위쪽에, 더 특수한 타입을 아래쪽에 배치하는 것이 관례다.
- 441p. 객체의 정의를 의미하는 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정을 의미한다. 반대로 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미한다.
- 441p. 내연의 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것이다.
- 442p. 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다. 일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스 보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
- 444p. 클라이언트 관점에서 두 클래스에 기대하는 행동이 다르다면 비록 그것이 어휘적으로 is-a 관계로 표현할 수 있다고 하더라도 사용해서는 안된다.
- 444p. 마틴 오더스키의 조언에 따르면 두 클래스가 어휘적으로 is-a관계를 모데링할 경우에만 상속을 사용해야 한다.
- 445p. 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다. 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.
- 445p. 타입 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
- 447p. 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족실 수 있는 방법을 찾기 쉽지 않다. 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것뿐이다.
- 449p. 인터페이스는 클라리언트가 기대한느 바에 따라 분리돼야 한다는 것을 기억하라.
- 452p. 자식 클래스가 부모 클래스의 코드르 재사용할 목적으로 상속을 사용했다면 그것은 서브클래싱이다. 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적으로 상속을 사용했다면 그것은 서브타이핑이다.
- 453p. 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
- 458p. 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을때만 올바르다.
- 458p. is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라느 점을 강조한다.
- 459p. 결론적으로 상속이 서프타이핑을 위해 사용될 경우에만 is-a 관계다.
- 460p. 자식 클래스가 클라이언트 관점에서 부모 클래스를 대채할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.
- 462p. 어떤 클래스가 다른 클래스를 상속받으면 그 클래스의 자식 클래스 또는 서브 클래스가 되지만 모든 서브 클래스가 서브타입인 것은 아니다.

### 🟢 초록색 부분

- 437p. 일반적으로 instaceof처럼 객체의 타입을 확인하는 코드는 새로운 타입을 추가할 때마다 코드 수정을 요구하기 때문에 개방-폐쇄 원칙을 위반한다.
- 444p. 마틴 오더스키의 조언에 따르면 두 클래스가 어휘적으로 is-a관계를 모데링할 경우에만 상속을 사용해야 한다.
