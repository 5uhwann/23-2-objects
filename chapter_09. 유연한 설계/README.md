# 삼색볼펜법을 통한 스터디 내용 정리

## 🔴 빨강
+ 282p 파란 글 (소프트웨어 개체(클래스, 모듈, 함수 등등)는..))
+ 283p 1번째문단 1번째줄 (개방-폐쇄 원친은 ~ 이야기한다.)
+ 283p 2번째문단 1번째줄: 사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기이다.
+ 284p 3번째문단 1번째줄: 개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이이다.
+ 286p 3번쨰문단 4번쨰줄 (추상확가 수정에 ~ 사실을 기억하라.)
+ 286p 마지막 문단 세 번째 문장
+ 287p 두 번째 문단 첫 번째 문장
+ 287p 4번째문단 2번째줄: 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제인 것이다.
+ 288p 파란 문장
+ 288P 1번째문단 1번째줄 : 유연하고 ~생성과 사용을 분리해야 한다.
+ 288p 1번째문단 3번쨰줄 (한 마디로 ~ 생성과 사용을 분리해야 한다.)
+ 289p 마지막 문단 마지막 문장
+ 291p 마지막 문단 첫 번째 문장
+ 292p [PURE FABRICATION 패턴] 두 번째 문단 첫 번째 문장
+ 292p 2번째문단 4번째줄: 도메인 개념을 표현하는 객체와 순수하게 창조된 가공의 객체들이 모여 자신의 역할과 책임을 다하고 조화롭게 협력하는 애플리케이션을 설계하는 것이 목표여야 한다.
+ 293p 두 번째 문단 세 번째 문장
+ 294P 3번째문단 1번째줄 : 메서드 주입은~ 사용할 수 있다.
+ 295P 1번째문단 2번째줄 : SERVICE LOCATOR는 ~ 저장소다.
+ 295p 마지막 문단 마지막 문장
+ 298P 5번째문단 1번째줄 : 문제의 원인은 ~ 위반했기 때문이다.
+ 298p 7번째문단 1번째줄: 숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다는 것이다.
+ 299p 네 번째 문단 마지막 문장
+ 301p. 6번째문단 1번째줄: 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.
+ 301p 6번째문단 2번째줄 (유연하고 재사용 ~ 따라야 한다.)
+ 304p 3번째문단 1번째줄 (따라서 의존성 ~ 역전시켜야 한다.)
+ 304p 5번쨰문단 1번째줄: 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.
+ 307p 2번째문단 3번째줄: 핵심은 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다는 것이다.
+ 307p 마지막 문단 첫 번째 문장


## 🔵 파랑
- 285p. 2번째문단 2번째줄: 추상화의 생략된 부분을 채워넣음으로써 새로운 문맥에 맞게 기능을 확장할 수 있다.
- 285p. 3번째문단 2번째줄: 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.
- 288p. 1번째문단 2번째줄: 한 마디로 말해서 객체에 대한 생성과 사용을 분리(separating use from creation)해야 한다.
- 301p. 1번째문단 3번째줄: 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 되는 것이다.

## 🟢 초록
+ 289P 6번째문단 1번째줄:이 경우 ~ 객체 생성에 특화된 객체를 FACTORY라고 부른다.
+ 291P 4번째문단 1번째줄:표현적 분해는 ~ 것이다.
+ 302p 두 번째 문단 전체 (이를 의존성 역전 원칙..라고 설명한다.)
+ 305p 5번째문단 1번째줄 (불필요한 ~ 낳는다.)
